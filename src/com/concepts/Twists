1) If two classes present, one parent class and child class and has IS-A relationship and have a test class
   P has m1() method, and C has m2() method
   where you create a object like P p = new C(); then you cannot access p.m2() method.
   
2) Auto Promotion in overloading

   Order: byte -> short
                         -> Int -> long -> float -> double  
          char  ->         
          
 3) Overloading: If String and Object accepting two different method arguments are present; same method name, if you pass null
      then which method would be invoked -> String method. Child class takes priority
      
 4) Overloading: If String and StringBuffer accepting two different method arguments are present; same method name, if you pass null
      then which method would be invoked -> 
      Both String and StringBuffer both are in same level, in hiearchy with Object -> so compile time error.
      

 5) In overriding, Child class overriden method, can change the return type from java 1.4 onwards
     But, it can be CO-variant return types. i.e., child classes can be used
     for Object Co-variant return type are -> any classes.
     for Number co-variant return type are -> Integer
     primitive data types are not allowed to change.
 
 6) Overriding -> related to access modifiers(public, protected, default, private)
 				Parent to child -> in child can increase scope (ex: from protected (Parent) to Public (Child))
 				
 7) Overriding -> related to exceptions
 				Parent to child -> in child can decrease scope (ex: from exception (Parent) to IOException (Child)) 		
 				
 				
 8) Overriding ->  with respective to Static methods.
 				   Overriding concept for static methods is not present, infact if we create a same method in child, then'
 			       it is called as method hiding.
 			       parent and child class has static void m1() method. P p = new C(); p.m1() -> would call parent m1() method.
 			       if non-static method then it is child method. but here it is parent m1 method would be invoked.
 
 9) a. Overloading P p = new C(); p.m1(); would call parent method, bcoz overloading happens in compile time.
    b. Overriding P p = new C(); p.m1(); would call child method, bcoz Overriding happens in run time.
 
 10) Overriding rules apply to only methods.
 		 	  	with respective to varibles
 		 	  	class P{ 
 		 	  	   int x = 888;
 		 	  	 }
 		 	  	 Class C {
 		 	  	    int x = 999;
 		 	  	 }  
 		 	  	 
 		 	  	 P p = new P(); p.x; // 888 ;;  C c = new C(); c.x; // 999 
 		 	  	 P p = new C(); p.x; // 888 ; variables we get based on reference type -> static or non static variables.
 		 	  	 
 11) You cannot create object for abstract classes, you have to extend abstract class and its child to create object.
     when child creates the object, the first line of child constructor, compiler automatically injects super() to call abstract class constructor.
     
 12) Abstract at class level:   Abstract class cannot be final. Abstract class cannot create object refer 11 point.
     Abstract at method level:  Abstract method should not have implementation. Abstract method cannot be final or static or private. final means cannot override. static belongs to class.
 	 Constructors at  Abstract classes: Abstract classes can have constructors, refer point 11 for more details.
 	 
 			       
 13) Interfaces: no implementation
                 all methods in an interface are public and abstract
                 any field (member) declared in interfaceis by default public static and final.
 			     Example: Created an Interface called Check and has one method validate, so 10 checks just implements Check(I) and
 			     write validate method implementation. While creating an object, based on check create object dynamically and pass that
 			     object to execute corresponding check.
 			     
 14) Wrapper classes
                Converting string to primitive datatypes
                parseInt(String x);
                parseDouble(String x);
                
                Converting string into wrapper classes
                Long l = Long.valueof(String x);
                
  15) Arrays:
                  int[] numbers = new int[5]; OR
                  int[] numbers new int[]{1,2,3,4,5,6,7,8,9};         
                  size is fixed, not auto growable, should go with array if we know size of the array. otherwise no use.
                  Ready made methods not available, DATA structure is not good, compare to collections.
                  
                  
  16) Collection: Growable in nature. Data structure is good. performance is good. Only Objects can hold.
  				   Collection is interface.
  				   Collections is class (utility class), which has Collections.sort(arraylist) method.
  				   												   Collections.search()
  				   												   
  17) ArrayList: Growable array
                 Duplicates allowed
                 inertion order preserved
                 Null insertion is possible												   
  				 All collection by default implements serializable, clonable inerface
  				 ArrayList and vector implements Random access interface
  				 If we want to get 1st index or 20th index or 50000 index value it takes same time due to RandomAccess
  				 For retrival purpose arraylist is better than linkedlist
  				 If frequent operation is retrival then better to go arraylist
  				 If add of any value in between and delete then we should not go for arralist, rather linkedlist is better.
  				 If in between anything to be added, then array will shift all its index to righ,same happens with delete.
  				 arraylist compare to vector, arraylist all methods are non-synchronized methods, while vector has all synch methods.            	     
 			     ArratList l1 = new ArrayList();
 			     List l = Collections.synchronizedList(l1);
 			     
 			      	      
 18) LinkedList: Growable array
                 Duplicates allowed
                 Insertion order preserved
                 Null insertion possible
                 doesnt implemenent RandomAccess
                 implements serializable, clonable inerface   
                 If we need to add new things in between or delete, then it is better to go with linkedlist
                 It doesn't shift index like ArrayList. 
                 Doubly linkedlist underlying data structure.
  
 19) Vector is exactly same as arraylist. Only difference is all methods in vector is synchronized methods.
      Vector v = new Vector();                 
 
 20) Stack: 
 			Child class of vector.
 			Stack s = new Stack();
 			Methods:
 			push, pop, peek; empty, search
 			
 21) Cursors of Java:
 		Iterator (for any collection object, can perform both read and remove operations)
 		Enumerator (applicable for vector and stack)
 		ListIterator				                                           
 		
 		Iterator itr  = l.iterator();
 		Methods: hasNext(), next(), remove()
 		
 		By using it itertor, Enumerator we can move forward only. so they call as Single direction cursors
 		Iterator, we can perform only read and remove operations. we cannot perform replacement of new objects.
 		To overcome, we have listIterator for list classes.
 		ListIterator is bi-directional cursor, move forward and also backward.
 		
 22) Set:
       Hashset, LinkedHashset
       SortedSet, Navigable set, Tree set.
       Insertion order not preserved.
       Duplicates are not allowed
       only one null is allowed.
       
       HashSet (C): Data Structure HashTable
                Insertion order not preserved, All objects inserted based on hashcode of objects.
                implements serializable, clonable interface.
                If search operation need to be done, then this is best interface.
                Load Factor: 0.75 -> This means initial capacity is 10, when 75% of objects fills, then it creates new object with more capacity.
                
       LinkedHashSet (C): HashTable+LinkedList (data structure)
        			  Insertion order is preserved
        			  
     
       SortedSet (I): It is the child interface of set.
                  Insert in some sorting order and duplicates are not allowed.
                  Implemenation class of SortedSet is TreeSet 	
                  
      TreeSet (C): Data Struture for Treeset is balanced Tree.
      			   Duplicates are not allowed.
      			   Insertion order not preserved, will be sorted based on Comparator passed.
      			   Null insertion is possible. only once.
      			   
      			   TreeSet t = new TreeSet(); // Default natural sorting order.
      			   TreeSet t = new TreeSet(Comparator c); // Customized sorting order. 
      			            	
 22) Comparable (Interface)
  			java.lang.package
  			one method -> public int compareTo(Object obj);
  					obj1.compareTo(obj2);
  					-ve iff obj1 has come before obj2
  					+ve iff obj1 has come after obj2
  					0 iff obj1 & obj2 are equal.
  					All wrapper classes, String class implements Comparable interface and 
  					in all wrapper classes and string class have implementation written for natural sorting order.
  					
 23) Comparator (Interface)
             Customized sorting order.
             methods: compare and equals.
             public int compare(Object obj1, Object obj2)
             -ve iff obj1 has come before obj2
  	      	 +ve iff obj1 has come after obj2
  			 0 iff obj1 & obj2 are equal.
  			 equals class implementation is optional, if you want specfic implementation, then you can implement.
  			 If you dont implement then, no error will come bcoz Object class has equls method, so that get invoked.	